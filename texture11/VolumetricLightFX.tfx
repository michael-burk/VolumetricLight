Texture2D tex0: PREVIOUS;
SamplerState s0 <bool visible=false;string uiname="Sampler";> {Filter=MIN_MAG_MIP_LINEAR;AddressU=BORDER;AddressV=BORDER;};
float2 R:TARGETSIZE;

Texture2D shadowMap <string uiname="shadowMap";>;
Texture2D depthMap <string uiname="depthMap";>;
//Texture2D worldPosMap <string uiname="worldPosMap";>;
Texture2D noiseTex <string uiname="noise";>;

Texture2D colTex <string uiname="colTex";>;

float4x4 tVI;
float4x4 tPI;
float4x4 tP;
float4x4 tVP;

float4 Color <bool color=true;>;
//float3 camDir;
float3 lightPos;
float3 lightDir;
float farPlane;
float fade;

static const float G_SCATTERING = -.2;
static const float PI = 3.14159265f;

int NB_STEPS = 32;

float4x4 shadowVP;

float brightness = 1;
float stepLength = 1;

float4 UVZtoVIEW(float2 UV,float z){
	float4 p=mul(float4(UV.x*2-1,1-2*UV.y,0,1.0),tPI);
	float ld = tP._43 / (z - tP._33);
	p=float4(p.xy*ld,ld,1.0);
	return p; 
}
float4 UVZtoWORLD(float2 UV,float z){
	return mul(UVZtoVIEW(UV,z),tVI); 
}


float3 UVtoEYE(float2 UV){
	return normalize( mul(float4(mul(float4((UV.xy*2-1)*float2(1,-1),0,1),tPI).xy,1,0),tVI).xyz);
}


	// Mie scaterring approximated with Henyey-Greenstein phase function.
	float ComputeScattering(float lightDotView)
	{
	float result = 1.0f - G_SCATTERING;
	result *= result;
	result /= (4.0f * PI * pow(abs(1.0f + G_SCATTERING * G_SCATTERING - (2.0f * G_SCATTERING) * lightDotView), 1.5f));
	return result;
	}

float4 VolumetricLight(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_TARGET{

// World Pos Approach
		
//			float3 startPosition = tVI[3].xyz;
//			float3 endRayPosition = (worldPosMap.Sample(s0,x).xyz);
//			float3 endRayPosition =  UVZtoWORLD(x,depthMap.Sample(s0,x).r).xyz;
//			float3 rayVector = endRayPosition - startPosition;
//			float rayLength = length(rayVector);
//			float3 rayDirection = rayVector / rayLength;
//			float stepLength = rayLength / NB_STEPS;
	
// UV to Eye Approach
	
		float3 endRayPosition =  UVZtoWORLD(x,depthMap.Sample(s0,x).r).xyz;
		// Ray Origin
		float3 startPosition = tVI[3].xyz;
		// Ray Direction
		float3 rayDirection = UVtoEYE(x.xy);
	
	
	float3 steppy = rayDirection * stepLength;

	startPosition += steppy * noiseTex.Sample(s0,x).r;
	
	float3 currentPosition = startPosition;
	
	float3 accumFog = 0.0f.xxx;
	float shadowMapValue;
	float4 worldInShadowCameraSpace;

	float distFactor;
	float3 lightToObject;
	for (int i = 0; i < NB_STEPS; i++)
	{	

		if( length(currentPosition - endRayPosition) <= stepLength) break;
		
		worldInShadowCameraSpace = mul(float4(currentPosition, 1.0f), shadowVP);
		worldInShadowCameraSpace /= worldInShadowCameraSpace.w;
		
		shadowMapValue = shadowMap.SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).r;
			
		lightToObject = lightPos - currentPosition ;

		if (shadowMapValue > worldInShadowCameraSpace.z && dot(lightToObject,lightDir) <= -.1)
		{	
			distFactor = saturate(1 - pow( mul(float4(currentPosition, 1.0f), shadowVP).z / farPlane * fade, 3));
			
//			accumFog += (ComputeScattering(dot(rayDirection, lightDir)).xxx * pow(rayLength,.5)) * distFactor * brightness *
//			colTex.Sample(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5).rgb*distFactor * brightness;

			accumFog += (ComputeScattering(dot(rayDirection, lightDir)).xxx) * pow( distFactor,1) * brightness *
			colTex.SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).rgb*distFactor * brightness;
			
		}
		
			currentPosition += steppy;
		
	}
	
	accumFog /= NB_STEPS ;
		
	
	return float4(accumFog,1)*Color;

}



technique10 Volumetric_Light{
	pass P1<string format="R32G32B32A32_float";>{SetPixelShader(CompileShader(ps_5_0,VolumetricLight()));}
}
