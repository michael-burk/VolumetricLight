SamplerState s0 <bool visible=false;string uiname="Sampler";> {Filter=MIN_MAG_MIP_LINEAR;AddressU=BORDER;AddressV=BORDER;};
SamplerState s1 <bool visible=false;string uiname="Sampler";> {Filter=MIN_MAG_MIP_LINEAR;AddressU=WRAP;AddressV=WRAP;};
float2 R:TARGETSIZE;

Texture2D shadowMap[32] <string uiname="shadowMap";>;
Texture2D depthMap <string uiname="depthMap";>;
Texture2D noiseTex <string uiname="noise";>;

Texture2D colTex[32] <string uiname="colTex";>;

float4x4 tVI;
float4x4 tPI;
float4x4 tP;

float4 Color <bool color=true;>;
StructuredBuffer <float> farPlane;
StructuredBuffer <float3> lPos;
float fade;

static const float G_SCATTERING = -.2;
static const float PI = 3.14159265f;

uint NB_STEPS = 32;

StructuredBuffer <float4x4> lightVP;

float brightness = 1;
float stepLength = 1;

uint lightCount = 0;

float4 UVZtoVIEW(float2 UV,float z){
	float4 p=mul(float4(UV.x*2-1,1-2*UV.y,0,1.0),tPI);
	float ld = tP._43 / (z - tP._33);
	p=float4(p.xy*ld,ld,1.0);
	return p; 
}
float4 UVZtoWORLD(float2 UV,float z){
	return mul(UVZtoVIEW(UV,z),tVI); 
}


float3 UVtoEYE(float2 UV){
	return normalize( mul(float4(mul(float4((UV.xy*2-1)*float2(1,-1),0,1),tPI).xy,1,0),tVI).xyz);
}
	// Mie scaterring approximated with Henyey-Greenstein phase function.
	float ComputeScattering(float lightDotView)
	{
	float result = 1.0f - G_SCATTERING /* * G_SCATTERING */;
	result *= result;
	result /= (4.0f * PI * pow(abs(1.0f + G_SCATTERING * G_SCATTERING - (2.0f * G_SCATTERING) * lightDotView), 1.5f));
	return result;
	}



float4 VolumetricLight(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_TARGET{

// UV to Eye Approach
	
		float3 endRayPosition =  UVZtoWORLD(x,depthMap.Sample(s0,x).r).xyz;
		// Ray Origin
		float3 startPosition = tVI[3].xyz;
		// Ray Direction
		float3 rayDirection = UVtoEYE(x.xy);
	
	float3 steppy = rayDirection * stepLength;

	startPosition += steppy * noiseTex.Sample(s0,x).r;
	
	float3 currentPosition = startPosition;
	
	float3 accumFog = 0.0f.xxx;
	float shadowMapValue;
	float4 worldInShadowCameraSpace;

	float distFactor;
	float3 lightToObject;

	float3 lightDir = 0;

	
	for (uint i = 0; i < NB_STEPS; i++)
	{	
		
		if( length(currentPosition - endRayPosition) <= stepLength) break;		
					
			
		[unroll]
		for (uint j = 0; j < lightCount; j++)
		{
			
			lightDir = float3(lightVP[j]._13, lightVP[j]._23, lightVP[j]._33);
			worldInShadowCameraSpace = mul(float4(currentPosition, 1.0f), lightVP[j]);
			worldInShadowCameraSpace /= worldInShadowCameraSpace.w;
		
		
			shadowMapValue = shadowMap[j].SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).r;
		
			if (shadowMapValue >= worldInShadowCameraSpace.z)
			{	
//				distFactor = saturate(1 - pow( mul(float4(currentPosition, 1.0f), lightVP[j]).z / farPlane[j] * fade, 3));
				distFactor =  pow(saturate( farPlane[j] * fade - length(currentPosition - lPos[j])), 1);
				accumFog += (ComputeScattering(dot(rayDirection, lightDir)).xxx) * distFactor * brightness * stepLength  *
				colTex[j].SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).rgb * distFactor * 100;
			}
			
		}
					
		
			currentPosition += steppy;
		
	}
	
	accumFog /= NB_STEPS ;
		
	
	return float4(accumFog,1)*Color;

}



technique10 Volumetric_Light{
	pass P1<string format="R16G16B16A16_float";>{SetPixelShader(CompileShader(ps_5_0,VolumetricLight()));}
}
