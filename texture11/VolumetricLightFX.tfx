//Texture2D tex0: PREVIOUS;

SamplerState s0 <bool visible=false;string uiname="Sampler";> {Filter=MIN_MAG_MIP_LINEAR;AddressU=BORDER;AddressV=BORDER;};

float2 R:TARGETSIZE;

Texture2D shadowMap <string uiname="shadowMap";>;
Texture2D depthMap <string uiname="depthMap";>;
Texture2D noiseTex <string uiname="noise";>;

//Texture2D worldPosMap <string uiname="worldPosMap";>;

Texture2D colTex <string uiname="colTex";>;

float4x4 tVI;
float4x4 tPI;
float4x4 tP;

float4 Color <bool color=true;>;
float farPlane;
float fade;

static const float G_SCATTERING = -.2;
static const float PI = 3.14159265f;

int NB_STEPS = 32;

float4x4 lightVP;

float brightness = 1;
float stepLength = 1;

float4 UVZtoVIEW(float2 UV,float z){
	float4 p=mul(float4(UV.x*2-1,1-2*UV.y,0,1.0),tPI);
	float ld = tP._43 / (z - tP._33);
	p=float4(p.xy*ld,ld,1.0);
	return p; 
}
float4 UVZtoWORLD(float2 UV,float z){
	return mul(UVZtoVIEW(UV,z),tVI); 
}


float3 UVtoEYE(float2 UV){
	return normalize( mul(float4(mul(float4((UV.xy*2-1)*float2(1,-1),0,1),tPI).xy,1,0),tVI).xyz);
}
	// Mie scaterring approximated with Henyey-Greenstein phase function.
	float ComputeScattering(float lightDotView)
	{
	float result = 1.0f - G_SCATTERING /* * G_SCATTERING */;
	result *= result;
	result /= (4.0f * PI * pow(abs(1.0f + G_SCATTERING * G_SCATTERING - (2.0f * G_SCATTERING) * lightDotView), 1.5f));
	return result;
	}

float4 VolumetricLight(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_TARGET{

// World Pos Approach
		
//			float3 startPosition = tVI[3].xyz;
//			float3 endRayPosition = (worldPosMap.Sample(s0,x).xyz);
//			float3 endRayPosition =  UVZtoWORLD(x,depthMap.Sample(s0,x).r).xyz;
//			float3 rayVector = endRayPosition - startPosition;
//			float rayLength = length(rayVector);
//			float3 rayDirection = rayVector / rayLength;
//			float stepLength = rayLength / NB_STEPS;
	
// UV to Eye Approach
	
		float3 endRayPosition =  UVZtoWORLD(x,depthMap.Sample(s0,x).r).xyz;
		// Ray Origin
		float3 startPosition = tVI[3].xyz;
		// Ray Direction
		float3 rayDirection = UVtoEYE(x.xy);
	
//			float3 rayVector = float3(0,3.3722,-6.1340) - startPosition;
//			float rayLength = length(rayVector);
//			float stepLength = rayLength / NB_STEPS;
	
	float3 steppy = rayDirection * stepLength;

	startPosition += steppy * noiseTex.Sample(s0,x).r;
	
	float3 currentPosition = startPosition;
	
	float3 accumFog = 0.0f.xxx;
	float shadowMapValue;
	float4 worldInShadowCameraSpace;

	float distFactor;
	float3 lightToObject;
	
//	float step = stepLength;

	float3 lightDir = float3(lightVP._13, lightVP._23, lightVP._33);

	
	for (int i = 0; i < NB_STEPS; i++)
	{	
		
		if( length(currentPosition - endRayPosition) <= stepLength) break;
		
		worldInShadowCameraSpace = mul(float4(currentPosition, 1.0f), lightVP);
		worldInShadowCameraSpace /= worldInShadowCameraSpace.w;
		
		shadowMapValue = shadowMap.SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).r;

		if (shadowMapValue >= worldInShadowCameraSpace.z)
		{	
			distFactor = saturate(1 - pow( mul(float4(currentPosition, 1.0f), lightVP).z / farPlane * fade, 3));
			accumFog += (ComputeScattering(dot(rayDirection, lightDir)).xxx) * pow( distFactor,1) * brightness * stepLength *
			colTex.SampleLevel(s0,float2(worldInShadowCameraSpace.x+1,-worldInShadowCameraSpace.y+1)*.5,0).rgb*distFactor * brightness;
			
		}
		
			currentPosition += steppy;
		
	}
	
	accumFog /= NB_STEPS ;
		
	
	return float4(accumFog,1)*Color;

}



technique10 Volumetric_Light{
	pass P1<string format="R16G16B16A16_float";>{SetPixelShader(CompileShader(ps_5_0,VolumetricLight()));}
}
