//@author: mburk
//@help: 
//@tags: filter
//@credits: http://blazelight.net/de/artikel/ssao-tutorial-deutsch.php

SamplerState blurSampler : register(s0); 
Texture2D linearDepth;
Texture2D tex;

Texture2D tex0: PREVIOUS;

SamplerState s0 <bool visible=false;string uiname="Sampler";> {Filter=MIN_MAG_MIP_LINEAR;AddressU=BORDER;AddressV=BORDER;};
float2 R:TARGETSIZE;

//float2 mapRange(float2 value, float from1,float to1,float from2, float to2){
//	
//	return  (value - from1) / (to1 - from1) * (to2 - from2) + from2;
//}


static const float2 g_kernel[4] = {
    float2(0.0f, 1.0f),
    float2(1.0f, 0.0f),
    float2(-1.0f, 0.0f),
    float2(0.0, -1.0f)
};

float4 upsampling(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_TARGET{
	
	float upSampledDepth = linearDepth.Load(int3(PosWVP.xy,0)).x;
	float3 color = 0.0f.xxx;
	float totalWeight = 0.0f;
	
	// Select the closest downscaled pixels.
	
//	int xOffset = PosWVP.x % 2 == 0 ? -1 : 1;
//	int yOffset = PosWVP.y % 2 == 0 ? -1 : 1;
//	
//	int2 offsets[] = {int2(0, 0),
//	int2(0, yOffset),
//	int2(xOffset, 0),
//	int2(xOffset, yOffset)};
	float downscaledDepth;
	for (int i = 0; i < 4; i ++)
	{
	
//		float3 downscaledColor = tex.Sample(int3(downscaledCoordinates + offsets[i], 0));
		
	float3 downscaledColor = tex.Load(int3(PosWVP.xy/4  + g_kernel[i], 0)).xyz;
	downscaledDepth = linearDepth.Load(int3(PosWVP.xy/4  + g_kernel[i], 0)).x;
	float currentWeight = 1.0f;
	currentWeight *= max(0.0f, 1.0f - (0.05f) * abs(downscaledDepth - upSampledDepth));
//	currentWeight *= (upSampledDepth - downscaledDepth);
	
	color += downscaledColor * currentWeight;
	totalWeight += currentWeight;
		
	}
	
	float3 volumetricLight;
	const float epsilon = 0.0001f;
	volumetricLight.xyz = color/(totalWeight + epsilon);
	
//	return upSampledDepth;
	return float4(volumetricLight.xyz, 1.0f);
}

technique10 RGB{
	pass P1{SetPixelShader(CompileShader(ps_4_0,upsampling()));}

}

